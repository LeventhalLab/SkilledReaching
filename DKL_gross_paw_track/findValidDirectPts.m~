function [ validDirectMask ] = findValidDirectPts( floorCoords, directMask, mirrorMask, boxCalibration, pawPref )
%UNTITLED3 Summary of this function goes here
%   Detailed explanation goes here

overlapThresh = 0.01;
validDirectMask = directMask;
K = boxCalibration.cameraParams.IntrinsicMatrix;

switch lower(pawPref)
    case 'left',
        valid_fc = floorCoords(2,:);
        fundMat = boxCalibration.srCal.F(:,:,2);
        P = boxCalibration.srCal.P(:,:,2);
    case 'right',
        valid_fc = floorCoords(1,:);
        fundMat = boxCalibration.srCal.F(:,:,1);
        P = boxCalibration.srCal.P(:,:,1);
end

[yd,xd] = find(directMask);
[yd,idx] = sort(yd,'descend');
xd = xd(idx);
epiLines = epipolarLine(fundMat,[xd,yd]);

[ym,xm] = find(mirrorMask);

lineVals = epiLines * [xm';ym';ones(1,length(xm))];
for i_dpt = 1 : length(yd)
    
    overlap_pts = abs((lineVals(i_dpt,:) < overlapThresh));
    if ~isempty(overlap_pts)    % epipolar line for this point overlaps with the mirror view
        switch lower(pawPref)
            case 'left',
                overlap_x_val = max(xm(overlap_pts));   % most anterior point if left paw
            case 'right',
                overlap_x_val = min(xm(overlap_pts));   % most anterior point if right paw
        end
        overlap_idx = find(xm == overlap_x_val,1,'first');
        test_pt = [xm(overlap_idx),ym(overlap_idx)];
        
        matched_pts = [xd(i_dpt),yd(i_dpt);test_pt];
        mpts_norm = normalize_points(matched_pts,K);
        
        [pt3d,~,~] = triangulate_DL(mpts_norm(1,:),mpts_norm(2,:),eye(4,3),P);
        if pt3d(2) > valid_fc(2)   % the highest this point in the direct view can be is still below floor level
            validDirectMask(yd(i_dpt),xd(i_dpt)) = false;
        end
        
    else    % epipolar line for this point does not overlap with the mirror view
        validDirectMask(yd(i_dpt),xd(i_dpt)) = false;
    end
   
end