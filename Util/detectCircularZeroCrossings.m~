function [idx, isLocalExtremum] = detectCircularZeroCrossings(x)

zerotol = 1e-10;

isLocalExtremum = false(length(x), 1);
if all(abs(x) < zerotol)    % all zeros
    idx = 1 : length(x);
    return;
end

% make sure x is a column vector
x_length = length(x);
if x_length == size(x,2)
    x = x';
end
z = [x;x];    % repeat x once so if the first point and last point have a zero crossing, it will be identified

test_sig = z .* circshift(z,-1);

idx_zeroCross = find(test_sig < 0);   % find points where the signal changes sign
if length(idx_zeroCross) == size(idx_zeroCross,2)
    idx_zeroCross = idx_zeroCross';
end
idx_zeroCross = idx_zeroCross(idx_zeroCross <= x_length);
idx_zeros = find(abs(z) < zerotol);
idx_nonzero = find(abs(z) > zerotol);

% condense consecutive indices where the function is equal to zero
idx_zeros_diff = diff(idx_zeros);
zeros_separate_start_idx = idx_zeros(find(idx_zeros_diff > 1)+1);
zeros_separate_end_idx = zeros(length(zeros_separate_start_idx),1);
for ii = 1 : length(zeros_separate_end_idx)
    if ~isempty(idx_nonzero(idx_nonzero > zeros_separate_start_idx(ii)))
        zeros_separate_end_idx(ii) = ...
            min(idx_nonzero(idx_nonzero > zeros_separate_start_idx(ii)));
    else
        zeros_separate_end_idx(ii) = 0;
    end
end
zeros_separate_end_idx = zeros_separate_end_idx - 1;
zeros_separate_start_idx(zeros_separate_start_idx > length(x)) = ...
    zeros_separate_start_idx(zeros_separate_start_idx > length(x)) - length(x);
zeros_separate_end_idx(zeros_separate_end_idx > length(x)) = ...
    zeros_separate_end_idx(zeros_separate_end_idx > length(x)) - length(x);
zeros_separate_start_idx = unique(zeros_separate_start_idx(zeros_separate_start_idx > 0));
zeros_separate_end_idx = zeros_separate_end_idx(1:length(zeros_separate_start_idx));

% ii = 1;
% while ii <= length(idx_zeroCross)-1
for ii = 1 : length(idx_zeroCross)-1
    if idx_zeroCross(ii + 1) - idx_zeroCross(ii) == 1
        isLocalExtremum(idx_zeroCross(ii:ii+1)) = true;
    end
end
%     ii = ii + 1;
% end
    
% now figure out if points where x == 0 are inflection points or local
% extrema
for ii = 1 : length(zeros_seprate_start_idx)
    if zeros_separate_start_idx(ii) == 1
        test_value = x(end) * x(zeros_separate_end_idx(ii) + 1);
    elseif zeros_separate_end_idx(ii) == length(x)
        test_value = x(end) * x(zeros_separate_start_idx(ii) - 1);
    else
        test_value = x(zeros_separate_start_idx(ii) - 1) * ...
            x(zeros_separate_end_idx(ii) + 1);
    end
    if zeros_separate_start_idx(ii) <= zeros_separate_end_idx(ii)
        temp_idx = zeros_separate_start_idx(ii) : zeros_separate_end_idx(ii);
    else
        temp_idx = [1 : zeros_separate_start_idx(ii), zeros_separate_end_idx(ii)
    if test_value > 0
        isLocalExtremum(
        
        

% NOW NEED TO FIGURE OUT HOW TO GET RID OF THE REDUNDANT POINTS...
% find distinct groupings of consecutive zero crossings
idx_diff = diff(idx);



% if length(idx) > 0
% for ii = 1 : length(idx)
%     if idx(ii)




if diff(idx) == 1   % if identify adjacent points, this means it's really a tangent point
    idx = idx(1);
end

zero_idx = find(abs(x) < zerotol);

% if there are two zero points, that means there are two tangent points
% along this line, and we'll just pick the first one since both points will
% define the same tangent line.


% WORKING HERE - NEED TO FIGURE OUT HOW TO MAKE SURE THAT ONLY TANGENT
% POINTS ARE KEPT - MAKE SURE THAT POINTS ON EITHER SIDE OF THE POINT AT
% WHICH LINEVALUE = 0 HAVE THE SAME SIGN
if length(zero_idx) > 1
    for ii = 1 : length(zero_idx)
        % check that sign of linevalue on either side of this point is the same
        % (or equal to zero)

        % find consecutive indices where x == 0
    end
end


if length(zero_idx) > 1
    zero_idx = zero_idx(1);
end

idx = [zero_idx;idx];
idx = unique(idx);
idx = sort(idx);